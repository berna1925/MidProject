# -*- coding: utf-8 -*-
"""미드톤.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1302yu2HYSix6c-fiGm7QdPv34WpPn5qR
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

dt = pd.read_excel('/content/2020~2024 국가별 데이터.xlsx')
dt.head()

dt.dropna(inplace=True)

result = dt[(dt['Ladder score'] > dt['upperwhisker']) | (dt['Ladder score'] < dt['lowerwhisker'])]['Ladder score']
result

dt.drop(['upperwhisker', 'lowerwhisker'], axis=1, inplace=True)

numerical_dt = dt.select_dtypes(include=np.number)
correlation_matrix = numerical_dt.corr()

# 2. 상관관계 히트맵 시각화
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)
plt.title('Correlation Matrix')
plt.show()
correlation_matrix = numerical_dt.corr()

plt.figure(figsize=(12, 6))
sns.barplot(x='Country name', y='Ladder score', data=dt, palette='viridis')
plt.title('Average Happiness Score by Region')
plt.xticks(rotation=45)
plt.show()

import requests
from bs4 import BeautifulSoup
import pandas as pd
import time
import random

def scrape_property_prices_index():
    """
    2025년 국가별 부동산 가격 지수 데이터를 스크레이핑합니다.
    스크레이핑된 데이터가 담긴 판다스 DataFrame을 반환합니다.
    """
    url = "https://www.numbeo.com/property-investment/rankings_by_country.jsp"

    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
    }

    try:
        response = requests.get(url, headers=headers)
        response.raise_for_status()

        soup = BeautifulSoup(response.text, 'html.parser')

        table = soup.find('table', {'id': 't2'})

        if not table:
            print("부동산 가격 테이블을 찾을 수 없습니다.")
            return None

        headers = []
        for th in table.find('thead').find_all('th'):
            headers.append(th.text.strip())

        data = []
        for row in table.find('tbody').find_all('tr'):
            row_data = []
            for td in row.find_all('td'):
                row_data.append(td.text.strip())
            data.append(row_data)

        df = pd.DataFrame(data, columns=headers)

        price_columns = [col for col in df.columns if 'Price' in col or 'Ratio' in col or 'Index' in col]
        for col in price_columns:
            if col in df.columns:
                df[col] = df[col].str.replace('[^\d.]', '', regex=True)
                df[col] = pd.to_numeric(df[col], errors='coerce')

        return df

    except requests.exceptions.RequestException as e:
        print(f"요청 중 오류 발생: {e}")
        return None
    except Exception as e:
        print(f"오류 발생: {e}")
        return None

def save_to_csv(df, filename="property_prices_index_2024.csv"):
    """
    DataFrame을 CSV 파일로 저장합니다.
    """
    if df is not None:
        df.to_csv(filename, index=False, encoding='utf-8-sig')
        print(f"데이터가 {filename}에 저장되었습니다.")
    else:
        print("저장할 데이터가 없습니다.")

def save_to_excel(df, filename="property_prices_index_2024.xlsx"):
    """
    DataFrame을 Excel 파일로 저장합니다.
    """
    if df is not None:
        df.to_excel(filename, index=False)
        print(f"데이터가 {filename}에 저장되었습니다.")
    else:
        print("저장할 데이터가 없습니다.")

if __name__ == "__main__":
    print("2024년 국가별 부동산 가격 지수 스크레이핑을 시작합니다...")
    df = scrape_property_prices_index()

    if df is not None:
        print(f"성공적으로 {len(df)}개 국가의 데이터를 스크레이핑했습니다.")
        print("\n샘플 데이터 (처음 5행):")
        print(df.head())

        # 데이터를 파일로 저장
        save_to_csv(df)
        save_to_excel(df)
    else:
        print("데이터 스크레이핑에 실패했습니다.")

ppp = pd.read_excel('/content/price to income ratio.xlsx')

merged_data = pd.merge(dt, ppp, left_on=['Country name','year'],
                      right_on=['Country','year'], how='inner')
merged_data

merged_data.to_csv('merged.csv', index=False)

numerical_md = merged_data.select_dtypes(include=np.number)

plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)
plt.title('Correlation Matrix')
plt.show()
correlation_matrix = numerical_md.corr()